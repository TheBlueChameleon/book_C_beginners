\chapter{Conditions and Decisions} \label{chp:Conditions}
\epigraph{In any moment of decision, the best thing you can do is the right thing, the next best thing is the wrong thing, and the worst thing you can do is nothing.}{Theodore Roosevelt}

The last chapter introduced some very limited form of interactivity by introducing the possibility to enter values at runtime. We now want to extend this interactivity by breaking out of the \emph{linear flux of control}: up to now, code is executed in exactly the order the code is written, and each line of code is executed. In this chapter, we will introduce ways to break out of this restriction and learn how to tie the execution of parts of our code to \emph{conditions}.

\section{Truth Values} \label{sec:truthvalues}
To arrive at our goal of conditionally executing portions of code, we first need to learn how to formulate a condition. For this, we introduce the mathematical concept of a \emph{truth value}. A mathematical expression can either be \emph{true} or \emph{false}. For example, the expression $1 + 5 \times 8 + 1 = 42$ holds \emph{true}, while $-1 > 1$ is \emph{false}. We can use the computer to evaluate the truthfulness of any expression. For that, we introduce a new set of comparison operators:

{
	\newcolumntype{C}{>{         \centering\arraybackslash} p{.20\linewidth}}
	\newcolumntype{O}{>{\ttfamily\centering\arraybackslash} p{.25\linewidth}}
	\rowcolors{1}{white}{tabhighlight}
\begin{tabularx}
	{\linewidth}
	{CO|CO}
\toprule[1.5pt]

	\textbf{Comparison}     & \normalfont \textbf{Operator Symbol}  &
	\textbf{Comparison}     & \normalfont \textbf{Operator Symbol}
\tabcrlf

	Equality       & ==   &  Inequality         & != \\
	Less than      & <    &  Greater than       & >  \\
	Less or equal  & <=   &  Greater or equal   & >= \\

\bottomrule[1.5pt]
\end{tabularx}
\captionof{table}{Comparison operators in C}\label{tab:OperatorsComparison}
}

Note that for equality, we use a \emph{double equals sign} to distinguish this comparison operation from the value assignment.

This notion of \emph{true} or \emph{false} can be represented with a single bit. But as you know from the last chapter, a processor can ever only handle byte sized chunks of bits. So, in this context, the wasteful approach was used: \emph{false} is represented by the value \inC{0} while any \emph{nonzero} value will be seen as \emph{true}.

With these new operators, we can translate our mathematical expressions into code. They evaluate to an \inC{int}, with which we can perform any operation that we already know. For example, the expression
\begin{center}
\inC{1 + 5 * 8 + 1 == 42}
\end{center}
is a somewhat convoluted way of computing the value \inC{1}.

Since comparisons are simply \inC{int} expressions, we can do computations with them, just like with \enquote{regular maths} expressions, including storing these results in \inC{int} variables:
\begin{codebox}[truthValues.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    int x     = 17;
    int truth = (x > 5) + (x < 5) + (x == 17);

    printf("%d true expressions.\n", truth);
}
\end{minted}
\captionof{code}{Storing turth values}
\end{codebox}

\begin{cmdbox}[Output: truthValues.c]
\begin{minted}{text}
2 true expressions.
\end{minted}
\end{cmdbox}

In this example, the three parentheses are evaluated one after another, yielding \inC{1} for \texttt{x > 5}, \inC{0} for \texttt{x < 5} and \inC{1} for \texttt{x == 17}. The three subexpressions are then summed up to give the result \inC{2}.

This is actually a thing we rarely ever do; but understanding helps us develloping a deep understanding how decision making works in a computer.

\begin{warnbox}[Symbols \texttt{true} and \texttt{false}]
In principle, you are free to use variables named \texttt{true} or \emph{false}. However, I strongly recommend against it. There are plenty of libraries (extensions to the C language) that define these symbols to mean \inC{1} or \inC{0}, respectively. They do so because expressions like \texttt{motorIsTurnedOn() == true} are just easier on human eyes than \texttt{motorIsTurnedOn() == 1}.

Defining the symbols to be constants with exactly these values is so common that when programmers see a piece of code with either of these symbols in it, they don't look up the definition, but simply assume that the symbols \emph{abide by the convention}. Going against this convention is a great way of confusing and annoying fellow coders.

While C does allow you to assign any value to the symbols \texttt{true} and \texttt{false}, most other programming languages don't. In C++, C\#, Java, Groovy and Python\footnote{In Python, the symbols actually are \texttt{True} and \texttt{False}, with a captial as a first letter. Still, The two words have a very strict definition in the programming community.}, they are \emph{reserved keywords}, \ie they are hard coded into the language itself. This is just one more reason not to adapt an unhealthy habit.
\end{warnbox}

\section{Conditional Execution of Code: \inC{if}}
\subsection{Simple \inC{if}}
Now that we know how to give answers to yes/no questions, we can tie portions of code to these answers. The keyword \inC{if} introduces an if...then block: \emph{if} some condition holds true, \emph{then} do things. In it's simplest form, this can be achieved with the following syntax:

\begin{codebox}[Syntax: Simple \texttt{if} block]
\begin{minted}{c}
if (condition) {
    statements
}
\end{minted}
\end{codebox}

In this, \texttt{condition} is anything that can be evaluated to a truth value. Usually, it is a comparison like \inC{x > 5}; but since truth values are essentially only numbers, any expression that evaluates to a number may be put here.

\texttt{statements} is one or several lines of code, \eg value assignments (\inC{x = 7 + y;}) or calls to functions (\inC{printf("hello world\n");}. These lines are executed as normal, but \emph{only if} \texttt{condition} \emph{is true}. Otherwise, they are skipped over, and the lines after the \inC{if} block are executed, \ie the lines after the closing curly brace \texttt{\}}.

Let's look at an example:
\begin{codebox}[evenNumbers.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    int foobar = 0;

    printf("Please enter an integer: ");
    scanf("%d", &foobar);

    if (foobar % 2 == 0) {
        printf("%d is an even number.\n", foobar);
    }

    printf("You entered %d.\n", foobar);
}
\end{minted}
\captionof{code}{Detecting and handling even numbers}
\end{codebox}

\begin{tcbraster}[raster columns=2,
                  raster equal height,
                  nobeforeafter,
                  raster column skip=0.2cm]
\begin{cmdbox}[Possible Output: evenNumbers.c]
\begin{minted}{text}
Please enter an integer: 5
You entered 5.
\end{minted}
\end{cmdbox}
%
\begin{cmdbox}[Possible Output: evenNumbers.c]
\begin{minted}{text}
Please enter an integer: 4
4 is an even number.
You entered 4.
\end{minted}
\end{cmdbox}
\end{tcbraster}

First we remember that the modulus operator \texttt{\%} computes the remainder of a division. If divided by 2, even numbers will have a remainder of zero, otherwise they will have a remainder of 1. So, in line 9 we really do ask whether the value of \texttt{foobar} is even. If and only if this is the case, we execute line 10. Otherwise, we jump ahead to the end of the \inC{if} block. The block began with the opening curly brace \texttt{\{} in line 9, and ends with its closing counterpart \texttt{\}} in line 11. The code outside of the \inC{if} block is always executed, regardless of the truth value.

\begin{warnbox}[Pet Peeve: \texttt{if} \enquote{loops}]
When discussing programming with beginners, I often hear the expression \inC{if} \emph{loops}. Please internalize that this wording is \emph{simply and completely wrong}. There is no such thing as \inC{if} \emph{loops}.

A loop is a structure that we'll discuss in detail in chapter \ref{chp:loops} and that allows to jump back in the code and execute the same code several times over. So, the \enquote{trajectory} through the code looks like a loop. Loops share a syntactical similarity with \inC{if} \emph{blocks} in that the looped part is enclosed in braces and initiated by a statement that comprises of a condition; this superficial similarity, however, is the only thing linking \inC{if} \emph{blocks} to loops.

So please, for the love of ones and zeros, do not even start using this abomination of an expression, and rather refer to the structure we're discussing in this chapter as an \inC{if} \emph{block}, or simply an \inC{if} statement.
\end{warnbox}



\begin{warnbox}[Common mistake: Comparison operator \texttt{==} vs. assignment operator \texttt{=}]
It is not uncommon to put an assignment (\texttt{=}) in lieu of a comparision in the condition of an \inC{if} block. \emph{Syntactically}, this makes sense: an assignment does have a return value that usually also is a valid truth value. \emph{Semantically}, it is in by far the most cases wrong -- assigning a value within an \inC{if} condition is hardly ever what we want. At best, it is a sign of bad style. At worst, it is plain wrong and produces a hard to find bug. For that reason, let's see how this bug looks like and how to spot it:
%\end{warnbox}
%%
%\begin{warnbox}[]

\begin{warnbox}[accidentalAssignment.c, leftupper=7mm]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    unsigned int rowCount = 0;
    printf("Number of rows:\n");
    scanf("%u", &rowCount);

    if (rowCount = 0) {
        printf("Error: cannot create empty table\n");
    }

    printf("Length of table: %d\n", rowCount);
}
\end{minted}
\captionof{code}{Accidental assignment in an \texttt{if} block}
\end{warnbox}

This produces the following behaviour:

\begin{cmdbox}[Possible output: accidentalAssignment.c]
\begin{minted}{text}
Number of rows:
5
Length of table: 0
\end{minted}
\end{cmdbox}

As mentioned before, line 8 does not compare \texttt{rowCount} to \inC{0} but assigns the value to the variable. The \emph{return value} of this assignment is the assigned value -- \ie the value \inC{0}, which in the context of the \inC{if} block becomes the truth value \emph{false}. Consequently, we do not see the message \texttt{Error: cannot create empty table}, but find an inconsistent state in line 12.

If you use the compiler flag \texttt{-Wall}, you will see a warning on compilation:

\begin{cmdbox}[Compilerwarnung: accidentalAssignment.c]
\begin{minted}{text}
accidentalAssignment.c: In function ‘main’:
accidentalAssignment.c:9:8: warning: suggest parentheses around assignment 
    used as truth value [-Wparentheses]
    if (rowCount = 0) {
        ^~~~~~~~
\end{minted}
\end{cmdbox}
\end{warnbox}

\begin{hintbox}[Style: Indention and position of braces]
I hope you noticed that I indented the code in the \inC{if} blocks, \ie I put additional four white spaces before the instruction in the \inC{if} block. We are currently only looking at very short codes of negligible complexity, so we could do without these indentations. We will, however, soon get to a level where this extra visual clue to the \emph{structure of our code} becomes an indespensable tool for our devellopment activities. So I want to double down on the fact \emph{that} you should make indentations whenever you open a block statement -- like \inC{if} -- and remove the indentation at the end of a block.

As to \emph{how} you make these indentations, there is no fixed rule that all programmers agree to and abide by. The number of whitespaces per indentation level varies from one through eight, and some prefer tabs instead of whitespaces. Likewise, some coders prefer putting the opening brace in the same line as the statement that \enquote{causes} the block (as I do), while others rather put the opening brace in a line of its own right. There are merits to both options. Some programmers like to advertise their style with almost religious zeal, and discussions can become very emotional, as shown in figure \ref{fig:IndentStyle}.

Whatever your preference in style may be, I will ask you to abide by these rules at the very least:
\begin{itemize}
\item Do make indentations to provide visual clues for the structure of your code
\item Keep your code uniform in look by maintaining the same kind of indentation per level and same position of braces (end of line or own line) for an entire project
\item Never change the indentation style of your colleagues
\end{itemize}
\end{hintbox}

\begin{figure}
	\href{http://www.sandraandwoo.com/2015/04/13/0674-there-are-10-types-of-programmers/}{
		\includegraphics[width=\linewidth]{./gfx/SW-indent-style}
	}
	\caption{A realistic scenario} \label{fig:IndentStyle}
\end{figure}

If there is only a single line of code that should be tied to the condition, then the \texttt{\{}curly braces\texttt{\}} can be ommitted. The above example can thus also be shortened to:
\begin{codebox}[evenNumbers.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    int foobar = 0;

    printf("Please enter an integer: ");
    scanf("%d", &foobar);

    if (foobar % 2 == 0)
        printf("%d is an even number.\n", foobar);

    printf("You entered %d.\n", foobar);
}
\end{minted}
\captionof{code}{Detecting and handling even numbers}
\end{codebox}

You may think of not having to type braces for one line \inC{if} blocks as a useful addition to the language. However, I strongly advise you against omitting braces, even in case of one line blocks. The reason for this advice is that it is not uncommon to amend code after it's written. If you do add lines of code to an \inC{if} block, you will have to remember adding the braces as well -- which you are very likely to forget. Even worse, the indentation that is supposed to help us to grasp the outline of our project will even conceal the error by guiding the eye and suggesting that the code has braces where there are none.

Regard this code listing \ref{code:missingBraces}:
\begin{warnbox}[missingBraces.c, leftupper=7mm]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    int foo = 0;

    printf("Please enter an integer:\n");
    scanf("%d", &foo);

    if (foo % 2 == 0)
        printf("%d is an even number.\n", foo);
        printf("%d is divisible by 2.\n", foo);

    printf("You entered %d.\n", foo);
}
\end{minted}
\captionof{code}{Incorrect \texttt{if} block (missing braces)} \label{code:missingBraces}
\end{warnbox}

As intended, line 10 is only executed if \texttt{foo} is even; line 11 on the other hand will \emph{always} be executed (like lin 13), regardless of the parity of \texttt{foo}. The indentation however, suggests that it, too, is tied to the condition in line 9.

If you add the braces as soon as you type \inC{if} you cant forget it when you later edit and amend the compound statement:
\begin{codebox}[correctedBraces.c]
\begin{minted}[linenos,firstnumber=9]{c}
    if (foo % 2 == 0) {
        printf("%d is an even number.\n", foo);
        printf("%d is divisible by 2.\n", foo);
    }
\end{minted}
\captionof{code}{Corrected \texttt{if} block (added braces)}
\end{codebox}



\subsection{\inC{if}-\inC{else}}
We can expand the syntax of \inC{if} blocks by an \inC{else} clause. As you'd expect, the statements in this block are executed only if the condition in the \inC{if} condition is \emph{not} satisfied.

\begin{codebox}[Syntax: \texttt{if}-\texttt{else} block]
\begin{minted}{c}
if (condition) {
    statements_true
} else {
    statements_false
}
\end{minted}
\end{codebox}

In a full code example, this could look like so:
\begin{codebox}[ifElse.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    int foo = 0;
  
    printf("Please enter an integer:\n");
    scanf("%d", &foo);

    if (foo % 2 == 0) {
        printf("%d is an even number.\n", foo);
    } else {
        printf("%d is an odd number.\n", foo);
    }
}
\end{minted}
\captionof{code}{\texttt{if}-{else} Blocks}
\end{codebox}

\begin{hintbox}[Bare numbers as conditions (1)]
We've learned that truth values are actually only numbers in special disguise. So whenever we test whether some expression evaluates to zero, we can omit the comparison operator, thereby creating marginally faster code, since the computer has to do one less computation step (computing the truth value). In that sense, we can re-write the former example:

\begin{codebox}[ifElseImplicitComparison.c]
\begin{minted}[linenos, firstnumber=7]{c}
    // ...
    
    if (foo % 2) {
        printf("%d is an odd number.\n", foo);
    } else {
        printf("%d is an even number.\n", foo);
    }
}
\end{minted}
\captionof{code}{\texttt{if}-{else} without explicit comparison}
\end{codebox}

We removed the \texttt{== 0} from line 9. Note that this also required flipping the true- and false case: \texttt{foo \% 2} is true when \texttt{foo} is odd, while \texttt{foo \% 2 == 0} was true when \texttt{foo} is even.
\end{hintbox}

You can nest \inC{if} blocks to almost arbitrary depth
\footnote{According to the C standard, \ie the rules according to which a C compiler has to be programmed, at least 127 levels of nested \texttt{if}s must be supported by the compiler (cf. \url{https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2310.pdf}. The gcc seems to only give an error message if you nest 6200 levels (cf. \url{https://stackoverflow.com/questions/764307/what-limits-the-number-of-nested-loops-in-c}), which should be way beyond any limit of practicality.}.
Hence, we can also implement sub-conditions, that are only evaluated if a primary condition was satisfied. In the following example, we test the parity of numbers again, but limit ourselves to positive numbers:

\begin{codebox}[ifElseNested.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    int foo = 0;
  
    printf("Please enter a positive integer:\n");
    scanf("%d", &foo);

    if (foo > 0) {
        if (foo % 2 == 0) {
            printf("%d is an even number.\n", foo);
        } else {
            printf("%d is an odd number.\n", foo);
        }
    } else {
        printf("%d is an invalid number.\n", foo);
    }
}
\end{minted}
\captionof{code}{Nested \texttt{if}-{else}}
\end{codebox}

Compare this to a -- syntactically valid -- version of the code without any indentations, and you will see why I put so much stress on the value of clear indentation:

\begin{warnbox}[ifElseNestedNotIndented.c, leftupper=7mm]
\begin{minted}[linenos]{c}
#include <stdio.h>
int main () {
int foo = 0;  
printf("Please enter a positive integer:\n");
scanf("%d", &foo);
if (foo > 0) {
if (foo % 2 == 0) {
printf("%d is an even number.\n", foo);
} else {
printf("%d is an odd number.\n", foo);
}} else {
printf("%d is an invalid number.\n", foo);
}}
\end{minted}
\captionof{code}{Nested \texttt{if}-{else} without indentations}
\end{warnbox}


\subsection{More than two cases in one \inC{if} block}
Sometimes we need to identify one of more than cases and act accordingly. If so, nested \inC{if}s are a viable means. In such a scenario, we can combine \inC{else} with a subsequent \inC{if} into a new structure\footnote{Technically, this is an application of the rule that one-line statements need no braces around them: \inC{if (condition_2) {statements}} is a one-line statement, even if \texttt{statements} takes up multiple lines. The braces bundle them together in one compound statement. Technically... \url{https://xkcd.com/1475/}}.:

\begin{codebox}[Syntax: Multi-case \texttt{if}-\texttt{else} block]
\begin{minted}{c}
if (condition_1) {
    statements_1
} else if (condition_2) {
    statements_2
} else if /* ... arbitrarily many else if blocks ... */ {
    statements_n
} else {
    statements_else
}
\end{minted}
\end{codebox}

In this form, we first evaluate \texttt{condition\_1}. If it is satisfied, the computer executes \texttt{statements\_1} and then jumps right to the end of the entire structure, \ie after the \texttt{else}, even if there are other conditions that would be met.

We can illustrate how this works in an example:

\begin{codebox}[ifMultiCase.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    int playerCount = -1;
    printf("How many players are there?\n");
    scanf("%d", &playerCount);

    if      (playerCount < 3) {printf("That's too few players.\n")}
    else if (playerCount > 8) {printf("That's too many players.\n")}
    else                      {printf("Great! Here are the rules: ...\n");}
}
\end{minted}
\captionof{code}{Multiple cases in an \texttt{if} block}
\end{codebox}

Here you see some code that does not perform as naively expected:
\begin{warnbox}[inaccessibleCode.c, leftupper=7mm]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
   int foo = 0;

   printf("Please enter an integer:\n");
   scanf("%d", &foo);

   if        (foo >  5) {
      printf("%d is greater than five.\n", foo);
   } else if (foo > 10) {
      printf("This line will never be printed on screen.\n");
   } else {
      printf("%d is less than five..\n" , foo);
   }
}
\end{minted}
\captionof{code}{Inaccessible code in a multi-case \inC{if} structure}
\end{warnbox}

\begin{cmdbox}[Possible Output: inaccessibleCode.c]
\begin{minted}{text}
Please enter an integer
50
50 is greater than five.
\end{minted}
\end{cmdbox}

The condition in line 11 is only ever evaluated, if the one in line 9 was already false. If the first condition \texttt{foo > 5} was true, then after printing \texttt{\%d is greater than five.}, code execution jumps right down to line 16, \ie the end of the code in this example.

\begin{defbox}[Flux of Control]
Lines 9-15 of the above code can be visualized in this flowchart:
\begin{center}
\begin{tikzpicture}
	[
		startstop/.style={rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=green!30!blue!30},
		decision/.style={diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=violet!30},
		process/.style={rectangle, minimum width=4.5cm, minimum height=1cm, text centered, draw=black, fill=yellow!30},
		arrow/.style={thick,->,>=stealth}
	]
	
	\node (enter) at (0, 9) [startstop] {line 7 (\emph{before} \texttt{if})};
	
	\node (cond1) at (0, 6) [decision]  {\texttt{foo > 5}?};
	\node (cond2) at (0, 3) [decision]  {\texttt{foo > 10}?};
	
	\node (if_1) [process] at (5, 6) {line 10 (\enquote{greater than five})};
	\node (if_2) [process] at (5, 3) {line 12 (\enquote{greater than ten})};
	\node (else) [process] at (5, 0) {line 14 (\enquote{less than five})};
	
	\node (eif_1) at (8, 6) {};
	\node (eif_2) at (8, 3) {};
	\node (eelse) at (8, 0) {};
	
	\node (leave) at (8, -2) [startstop] {line 16 (\emph{after} \texttt{if})};
	
	\draw [arrow] (enter)  -- (cond1);
		
	\draw [arrow] 
		(cond1) -- 
		node [text width=1.2cm, midway, align=center] 
			{\color{green!70!black} yes \\ \phantom{.}}
		(if_1);
	
	\draw [arrow] 
		(cond1) -- 
		node [text width=1.2cm, midway, align=left] 
			{\color{red!70!black} no}
		(cond2);
		
	\draw [arrow] 
		(cond2) -- 
		node [text width=1.2cm, midway, align=center] 
			{\color{green!70!black} yes \\ \phantom{.}}
		(if_2);
	
	\draw [arrow] 
		(cond2) |- 
		node [text width=1.2cm, midway, align=left] 
			{\color{red!70!black} no}
		(else);
	
	\draw [arrow] (if_1) -| (leave);
	\draw [arrow] (if_2) -- (eif_2);
	\draw [arrow] (else) -- (eelse);
	\draw [arrow] (eif_1) -- (leave);
\end{tikzpicture}
\end{center}
\captionof{figure}{Flux of control in an \texttt{if}..\texttt{else if} block}

\vspace{3pt}
There is no logically possible path leading to \emph{line 12}, because it would have to pass through \texttt{foo > 5} with \emph{no} and through \texttt{foo > 10} with \emph{yes}.
\end{defbox}


\section{Logical Operators} \label{sec:OperatorsLogical}
Sometimes, execution of a piece of code should depend on more than one condition. For example, before writing a file, it has to be made sure that enough storage space is availabe \emph{and} that the filename is valid. We could achive this by nesting \inC{if} statements:

\begin{codebox}[andNested.c]
\begin{minted}[linenos, firstnumber=420]{c}
    // ...
    
    if (availableDiskSpace < 1024) {
        if (countOfInvalidCharactersInFilename > 0) {
            printf("Error: Could not write file!\n");
        }
    }
    
    // ...
\end{minted}
\captionof{code}{Nested \inC{if} to realize a logical \emph{and}}
\end{codebox}

But I am pretty sure, you already noticed that we could also collapse this into a single \inC{if} statement by using the \emph{and} operation from the previous chapter. A comparison like \texttt{<} or \texttt{>} produces an integer, which is either 1 or zero. We can join several ones and zeros with the bitwise operators \texttt{\&}, \texttt{|} and \texttt{\textasciicircum}. Thus, the same result is achieved by this code:
\begin{codebox}[andBitwise.c]
\begin{minted}[linenos, firstnumber=420]{c}
    // ...
    
    if ((availableDiskSpace < 1024) & (countOfInvalidCharactersInFilename > 0)) {
        printf("Error: Could not write file!\n");
    }
    
    // ...
}
\end{minted}
\captionof{code}{Bitwise operator joins two conditions in an \inC{if} statement} \label{code:bitwiseAndIf}
\end{codebox}

For reasons I will explain in the next few paragraphs, in such a situation we would prefer \emph{logical operators} over \emph{bitwise operators}. Each of the bitwise operators (\emph{and}, \emph{or}, \emph{xor} and \emph{not}) has a logical counterpart. Both kinds of operators perform the same principle operations; \emph{true and true} will always give \emph{true}, no matter whether you perform a bitwise or a logical \emph{and}. The primary difference between the two is that the logical operators first reduce their operands to \emph{booleans}, i.e. to a single true/false value.

The \emph{bitwise} and between \texttt{11 == 1011$_2$} and \texttt{7 == 0111$_2$} is \texttt{3 == 0011$_2$}. The \emph{logical} and, on the other hand, is simply \texttt{1} or \emph{true}, because both operands \texttt{11} and \texttt{7} are nonzero and therefore count as \emph{true}. Table \ref{tab:logicalAndBitwiseOperators} shows which symbols are used for which operation:

{
\newcolumntype{N}{>{         \centering\arraybackslash} p{.15\linewidth}}
\newcolumntype{R}{>{\ttfamily\centering\arraybackslash} p{.25\linewidth}}
\begin{center}
\rowcolors{1}{white}{tabhighlight}
\begin{tabularx}
	{.73\linewidth}
	{NRR}
\toprule[1.5pt]

    \textbf{Operation} & \textrm{\textbf{Bitwise Operator}}  &  \textrm{\textbf{Logical Operator}}
\tabcrlf
    and &               \& & \&\& \\
    or  &               |  & ||   \\
    xor & \textasciicircum & !=   \\
    not & \textasciitilde  & !    \\

\bottomrule[1.5pt]
\end{tabularx}
\end{center}
\captionof{table}{Logical and bitwise operators in C}\label{tab:logicalAndBitwiseOperators}
}

Note that it is not a mistake to put the inequality operator \texttt{!=} in the table as the logical xor operator. If you compare to the behaviour listed in table \ref{tab:booleanLogic}, you will find that \emph{inequality} is exactly what a logical xor tests for.

So, why should we write
\mint{c}{if ((availableDiskSpace < 1024) && (countOfInvalidCharactersInFilename > 0))}
instead of using a bitwise operator like in code listing \ref{code:bitwiseAndIf}?

In day-to-day life, the principal reason is semantics: using a logical operator says that we really only care about yes-or-no information; bitwise operators on the other hand imply that some black magic on individual bits is happening\footnote{which usually makes experienced coders nervous}. They also allow treating values in themselves as truth values. Compare these two pieces of code:
{
\begin{tcbraster}[raster columns=2,
                  raster equal height,
                  nobeforeafter,
                  raster column skip=0.2cm]
\begin{codebox}[nonzeroLogicalAnd.c]
\begin{minted}[linenos, firstnumber=69]{c}
if (x && y) {
  printf("Both x and y are nonzero.");
}
\end{minted}
\end{codebox}
%
\begin{codebox}[nonzeroBitwiseAnd.c]
\begin{minted}[linenos, firstnumber=69]{c}
if ((x != 0) & (y != 0)) {
  printf("Both x and y are nonzero.");
}
\end{minted}
\end{codebox}
\end{tcbraster}
\captionof{code}{Bitwise and logical conjunction for nonzero-test}
}

The left example using the logical and works in this shortened form no matter what values \texttt{x} and \texttt{y} store. For the bitwise operators, on the other hand, an explicit comparison to zero is needed\footnote{You might still find the right hand side form easier to understand due to its explicitness, and this point of view has its merit. Of course, you can always combine both versions, \ie use logical operators with explicit comparisons.} (think of the example \texttt{x = 1} and \texttt{y = 2}. Without the explicit comparison, the bitwise \emph{and} would give \texttt{0} or false).

Another major difference is the fact that the bitwise \emph{and} and \emph{or} are \emph{short circuited}. This means that the computer tries to save some time by evaluating the second operand only when this is necessary. You know that for an \emph{and}, both operands need to be \emph{true}. If the left hand side operand is already known to be \emph{false}, we automatically know that the result of the \emph{and} will always be \emph{false}, no matter what comes to the right of it. This can be used to prevent nonsensical operations:
\begin{codebox}[Example: preventDivByZero.c]
\begin{minted}[linenos, firstnumber=69]{c}
if (x && (y / x > 5)) {
    printf("Treshold surpassed");
}
\end{minted}
\captionof{code}{Short circuiting}
\end{codebox}

We know that a division by zero is ill-defined. This also holds for programming in C: a program trying to divide by zero will usually crash\footnote{unless you are using floating point numbers... but more on that in chapter \ref{chp:misc}.}, which is obviously bad. For that reason, we should always make sure the denominator of a division is nonzero. In the above example, due to the short circuiting behavior of the logical \emph{and}, the expression \texttt{y / x} is only evaluated if \texttt{x} itself was already nonzero.

In a similar manner, the logical or (\texttt{||}) evaluates its right hand side operand only if the left hand side was \emph{false}, because \emph{true or anything} will always be \emph{true}.

\begin{hintbox}[Rule of thumb: two character operators with \texttt{if}]
We already encountered the fact that the assignment operator (\texttt{=}) is usually misplaced in an \inC{if} statement. We have seen that confusing the bitwise operators with the logical ones can have unintended consequences, too.

While it sadly does not always hold, I recommend you to adopt the rule of thumb: \emph{an \inC{if} requires a two-character operator} (\ie \texttt{==}, \texttt{\&\&}, ...). Notable exceptions from this rule are \texttt{<}, \texttt{>} and \texttt{!}, and every time you do evil bit hacking.
\end{hintbox}

\begin{hintbox}[Bare numbers as conditions (2)]
Whether or not a number is nonzero is a question we have to answer very often in programming. We've already learned that we can drop the explicit comparision to zero when the code we want to run code if some number is \emph{nonzero}. With the logical \emph{not}, we can also run code only when it is \emph{zero}:

\vspace{6pt}
\begin{codebox}[implicitIfZero.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    unsigned int rowCount = 0;
    printf("Number of rows:\n");
    scanf("%u", &rowCount);

    if (!rowCount) {
        printf("Error: cannot create empty table\n");
    }
}
\end{minted}
\captionof{code}{Logical \emph{not} to test for zero values}
\end{codebox}
\end{hintbox}

In particular using the \emph{or} conjunction can help reduce redundant code. Regard the following example:
{
\begin{tcbraster}[raster columns=2,
                  raster equal height,
                  nobeforeafter,
                  raster column skip=0.2cm]
\begin{warnbox}[ifSequence.c, leftupper=7mm]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    unsigned int playerCount = 0;

    printf("number of players:\n");
    scanf("%u", &playerCount);

    if (playerCount < 2) {
        printf(
            "Game not apt for %d ",
            playerCount
        );
        printf("players.\n");
    }

    if (playerCount > 5) {
        printf(
            "Game not apt for %d ",
            playerCount
        );
        printf("players.\n");
    }
}
\end{minted}
\end{warnbox}
%
\begin{codebox}[ifConjunction.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    unsigned int playerCount = 0;

    printf("number of players:\n");
    scanf("%u", &playerCount);

    if ((playerCount < 2) ||
        (playerCount > 5)
       ) {
        printf(
            "Game not apt for %d ",
            playerCount
        );
        printf("players.\n");
    }
}
\end{minted}
\end{codebox}
\end{tcbraster}
\captionof{code}{Avoiding redundant code with logical operators}
}

Not only is the right hand side code much shorter; it is also easier to maintain and debug. If we later want do more than only print a warning that a given player number is not suitable, in the left hand code we need to edit in these changes in two places, and are therefore twice as likely to make typos or (most dangerously) can outright forget to edit the second \inC{if} statement.

\begin{hintbox}[Avoid redundant code]
Whenever you feel like copy-pasting your code, always think twice whether there is not a possibility to restructure your code such that you avoid redundancy. Experience shows that you always spend \emph{way longer} to find and fix bugs due to redundancy than it takes to refactor your code into a more maintainable form.
\end{hintbox}

\section{Many cases: \inC{switch}}
The command \inC{switch} can be understood as a short-form of the \inC{if} statement that is useful when there are many different values one expression has to be compared to. Below you will find the syntax of the \inC{switch} statement and its (almost\footnote{an \texttt{expression} can have side effects. An example is \texttt{variable++}, in which incrementing \texttt{variable} is a side effect. In the \inC{switch} form, \texttt{expression} is evaluated only once, which means that the side effects occur only once}. With \inC{if}, on the other hand, each \texttt{expression} up to the first one that yields \emph{true} is evaluated, which implies effecting multiple side effects) equivalent \inC{if} form:

\begin{tcbraster}[raster columns=2,
                  raster equal height,
                  nobeforeafter,
                  raster column skip=0.2cm]
\begin{codebox}[Syntax: \texttt{switch}]
\begin{minted}{c}
switch (expression) {
    case value_1 :
        statements_1;
        break;
    case value_2 :
        statements_2;
        break;
    ...
    default:
        statements_else;
}
\end{minted}
\end{codebox}
%
\begin{codebox}[Syntax pendant: \texttt{if}]
\begin{minted}{c}
if        (expression == value_1) {

    statements_1;
    
} else if (expression == value_2) {
    statements_2;
    
...
} else {
    statements_else;
}
\end{minted}
\end{codebox}
\end{tcbraster}

So, syntactically, \inC{switch} allows omitting to type \texttt{expression} again and again, which in practice can be quite handy and often improves code legibility.

Like the \inC{else} clause in an \inC{if} block, the \inC{default} label is optional.

You surely noticed the \inC{break} statement in the \inC{switch} syntax. This statement leaves the current block, \ie jumps to the statement after the closing brace (\texttt{\}}) of the \inC{switch} block. It is allowed to not use a \inC{break} statement at the end of a \inC{case} section; the effect of this is that the statements of the subsequent \inC{case} section(s) are executed as well, up to the point where the first \inC{break} statement is hit or where the \inC{switch} block ends, regardless of whether \texttt{expression} actually equals the values of the subsequent \inC{case} labels. We say, we cann \emph{fall through} a \inC{switch case}.

Albeit very similar in the function it performs, a \inC{switch} command is translated into machine language in a very different fashion from a \inC{if} block. This results in several differences:
\begin{itemize}
\item \inC{switch} can only be used with integer-like expressions (\ie \texttt{expression} has to evaluate to an \inC{int}, \inC{short int}, \inC{unsigned char}, ..., 
	but not to a \inC{float}, \inC{double}, ... or any pointer.)
\item The values that \texttt{expression} is compared to must be \emph{compile time constants}. That means they must have a fixed value when they are compiled and may not variables 
	(but can be formulated as a result of operations). For example, \inC{7}, or \inC{99 + 1} are valid expressions for the \inC{case} \emph{labels}, but \inC{x + 1} is not.
\item These restrictions allow for greater optimization: going through a \inC{switch} statement can be significantly faster than going through its \inC{if} counterpart.
\item The values in the \inC{case} labels must be unique; it is not allowed to have one label testing for the value \inC{7} and another one testing for \inC{6 + 1}. 
	(In its \inC{if} counterpart, multiple cases with the same value are allowed, but meaningless, as only the first block meeting a condition is exectued.)
\item Fallthrough behaviour is only possible in \inC{switch} statements, but not  in \inC{if} blocks. Using \inC{break} outside of a \inC{switch} block (or a \inC{for}- or \inC{while} loop which we will only learn about in chapter \ref{chp:loops}) constitutes a syntax error.
\end{itemize}

An example for a \inC{switch} block might look like this:
\begin{codebox}[menu.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
   int selection = -1;

   printf("Please enter your choice:\n");
   printf("  1) Start game\n");
   printf("  2) Options\n");
   printf("  3) Highscore\n");
   printf("  0) Quit\n");

   scanf("%d", &selection);
   switch (selection) {
      case 1 :
         // code for start game ...
         break;
      case 2 :
         // code for options ...
         break;
      case 3 :
         // code for show highscore ...
         break;
      case 0 :
         // code for quit game
         break;
      default:
         printf("invalid choice!\n");
         break;
   }
}
\end{minted}
\captionof{code}{A menu with \inC{switch}}
\end{codebox}

Like with \inC{if}, you can nest \texttt{switch} statements. More so, you can have \texttt{if} blocks within \inC{switch} blocks and vice versa, up to (virtually) arbitrary depth.

The most common scenario where one would drop the \inC{break} statement is when multiple values should trigger the same response, \ie the equivalent form of:
\mint{c}{if (expression == value_1 || expression == value_2 || ...) {statements;}}
The corresponding \inC{switch} block then comprises a list of empty \inC{case} sections and the actual treatment in the last section:
\begin{minted}{c}
switch(expression) {
    case value_1:
    case value_2:
    ...
    case value_n:    
         statements;
}
\end{minted}

Another scenario where leaving out the \inC{break} statement can be useful is when a variable defines a \enquote{level of escalation}: multiple tactics to handle a problem can be deployed, and each level builds on the previous one. Instead of a complex chain of \inC{else if}s with logical \emph{or}s, the \inC{switch} command allows to handle the scenario as in the following scenario
\footnote{Note that the line numbers in this fictional example are in the thousands. This is absolutely not uncommon. Even medium sized projects can easily grow into the tens of thousands of lines of code, and bigger projects can comprise millions of lines of code. Consequently, it is very important to follow the best practices laid out in this book in order to not get lost in your own code.}:
\begin{codebox}[levelOfAccuracy.c, leftupper=9mm]
\begin{minted}[linenos, firstnumber=1337]{c}
    // ...
    
    switch (levelOfAccuracy) {
        case 3:
            printf("Considering quantum effects\n");
            // ...
        
        case 2:
            printf("Loading general relativity module\n");
            // ...
            
        case 1:
            printf("Enabling dynamic adjustment of grid resolution\n");
            // ...
            break;
            
        default:
            printf("Invalid choice\n");
    }
    
    // ...
\end{minted}
\captionof{code}{Activating successive refinement levels with \inC{switch}} \label{code:levelsOfAccuracy}
\end{codebox}

Note that there still is a \inC{break} statement in line 1351. Only the cases \texttt{1..3} are connected in that way.

\begin{hintbox}[Comment intentional fall through]
We now understand that omitting the \inC{break} triggers fallthrough behaviour. This is sometimes intentional, but often a bug. For that reason, the compiler utters a warning when a fallthrough situation is found and the compiler flag \texttt{-Wextra} is active. Code listing \ref{code:levelsOfAccuracy} will therefore produce a compiler output like the following:

\vspace{6pt}
\begin{cmdbox}[Compiler Warning: Fallthrough]
\begin{minted}{text}
fallthrough.c: In function ‘main’:
fallthrough.c:8:10: warning: this statement may fall through 
    [-Wimplicit-fallthrough=]
 1341 |          printf("Considering quantum effects\n");
      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
fallthrough.c:11:7: note: here
 1344 |       case 2:
      |       ^~~~
...
\end{minted}
\end{cmdbox}

To mark the fallthrough behaviour as intentional (to both, the compiler and a future human reader), you should put a comment containing the word \texttt{fallthrough} at the end of the \inC{case} label without a \inC{break} statement. In the case of code listing \ref{code:levelsOfAccuracy}, putting \inC{// fallthrough} in lines 1343 and 1347 suppresses the compiler warning and tells a later reader of the code that this was in fact intentional.

Even better is of course adding a reason for why the fall through is intentional:\\
\inC{// fallthrough: quantum effect correction is much smaller than that of GR}
\end{hintbox}

\section{Conditional Assignment of Values -- the Ternary Operator \texttt{?}}
Frequently, one of two values must be assigned to a variable, depending on a condition. We can now solve this with the pattern:
\begin{codebox}[conditionalAssignmentIf.c]
\begin{minted}[linenos]{c}
    // ...
   
    if (condition) {
        variable = value_1;
    } else {
        variable = value_2;
    }
    
    // ...
\end{minted}
\captionof{code}{Conditional assignment of a value with \inC{if}}
\end{codebox}

The same can be achieved with the \emph{ternary operator} (so called because it takes \emph{three} operands):
\begin{codebox}[conditionalAssignmentTernaryOperator.c]
\begin{minted}[linenos]{c}
    // ...
    
    variable = condition ? value_1 : value_2;
    
    // ...
\end{minted}
\captionof{code}{Conditional assignment of a value with the ternary operator}
\end{codebox}

If \texttt{condition} is \emph{true}, this operator evaluates to \texttt{value\_1}, otherwise it yields \texttt{value\_2}. Note that this needs not even appear in an assignment, but can be part of another expression. For example, the mathematical expression:
\[ |x| \cdot |y| + 7 \]
can be transscribed into code like this:
\begin{center}
	\inC{(x > 0 ? x : -x) * (y > 0 ? y : -y) + 7}
\end{center}

Another common use is conditionally passing one of two arguments to a function, like in the following example to \texttt{printf}:
\begin{codebox}[conditionalString.c]
\begin{minted}[linenos]{c}
    // ...
    
    int temperature = /* code that measures the current air temperature */
    
    printf("Today it is %s\n",
           temperature > 20 ? "warm enough" : "too cold"
    );
    
    // ...
\end{minted}
\captionof{code}{Number-to-text conversion with the ternary operator}
\end{codebox}


\section{Main Takeaways}
\begin{defbox}[You should remember...]
\begin{itemize}
\item Truth values are integers that represent the idea of \emph{true} if nonzero or \emph{false} otherwise.
	They are obtained by evaluating expressions containing comparison operators.
\item Logical operators take multiple values, treat them as truth values and compute a new truth value from them.
	The operators are \emph{and} (\texttt{\&\&}), \emph{or} (\texttt{||}) and \emph{not} (\texttt{!}).
	The logical \emph{xor} can be implemented with the inequality comparison operator (\texttt{!=}).
\item A truth value can be used in an \inC{if} statement. The code tied to it will only be executed if the truth value was \emph{true}
\item Optionally, an \inC{if} statement may have an \inC{else} clause. Code in this clause will only be executed if the truth value was \emph{false}.
\item Multi-case \inC{if} statement can be constructed with the \inC{else if} pattern.
	Even if multiple conditions are met, only the code pertaining to the first matching condition will be executed, though.
\item The \inC{switch} statement is a more compact, better legible and more optimized form of the multi-case \inC{if}.
	It only works on \emph{integers} with \emph{compile time} cases, but allows fallthrough constructions.
\item The \inC{break} statement prevents fallthrough constructions.
\item The ternary operator returns one of two values, depending on a condition.
\end{itemize}
\end{defbox}


\newpage
\section{Exercises and Solutions}
\subsection*{Discriminant}
Write a program that asks the user for the three parameters $a, b, c$ of a parabola. Then compute the discriminant and print on screen whether there are no, one or two real-valued roots to the parabola.

Why can't this task be solved with a \inC{switch} statement?

\emph{Remember:}\\
A parabola is given by the equation:
\[ y = ax^2 + bx + c \]
The roots are the values for $x$ where $y = 0$. These roots can be found from the expression
\[ x_{\pm} = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} \]
The portion under the root, \ie the expression
\[ b^2 - 4ac \]
is called the \emph{discriminant}. Depending on its relation to zero (less than, equal to or greater than) there are no, one or two solutions to this equation.

\subsection*{Biggest number}
Write a program that asks the user for three numbers. Find the biggest number among these.

\subsection*{Logical vs. Bitwise Operator}
Convince yourself that \inC{5 & 2} evaluates to \emph{false} while \inC{5 && 2} evaluates to \emph{true}. Do you understand why that is?

\subsection*{Equivalence}
Which of these expressions give the same results? (The variables \texttt{x}, \texttt{y} and \texttt{z} are of type \inC{int} with unknown value)
\begin{itemize}
\item \texttt{x > 0} and \texttt{!(x < 0)}
\item \texttt{!!x} and \texttt{x != 0}
\item \texttt{x || !x} and \texttt{1}
\item \texttt{!(x || y)} and \texttt{(!x) \&\& (!y)}
\item \texttt{!(x \&\& y)} and \texttt{!x \&\& !y}
\item \texttt{x || (y \&\& z)} and \texttt{(x || y) \&\& (x || z)}
\end{itemize}
\vfill

\subsection*{Non-Equivalent \inC{switch}/\inC{if} constructs}
First regard the following code, and convince yourself that the output on screen will be \texttt{one}:
\begin{codebox}[exo5-5a.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
   int var = 0;

   switch (++var) {
        case 0:
            printf("zero\n");
            break;

        case 1:
            printf("one\n");
            break;

        case 2:
            printf("two\n");
            break;

        default:
            printf("other\n");
    }
}
\end{minted}
\end{codebox}

Now look at the following code which seems to be the equivalent \inC{if}-form of the above code. What output will it produce? Why is it not the same as above?
\begin{codebox}[exo5-5b.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    int var = 0;

    if        (++var == 0) {
        printf("zero\n");
    } else if (++var == 1) {
        printf("one\n");
    } else if (++var == 2) {
        printf("two\n");
    } else {
        printf("other\n");
    }
}
\end{minted}
\end{codebox}
\vfill

\subsection*{Refactory}
Refactor the following code (\ie rewrite it in a better fashion) as to avoid the redundancy and make it more compact:
\begin{codebox}[exo5-6.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    int var = /* some value */;

    if (var % 2 == 1) {
        if (var >= 5) {
            printf("%d is odd and between 5 and 10.\n", var);
        }
        
        if (var <= 10) {
            printf("%d is odd and between 5 and 10.\n", var);
        }
    }
}
\end{minted}
\end{codebox}

Can you also come up with a shorter form of this piece of code:
\begin{codebox}[exo5-6-bonus.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    int var = /* some value */;

    if (var % 2 == 1) {
        if (var % 5 == 1) {
            printf("The last digit of %d is 1.\n", var);
        }
    }
}
\end{minted}
\end{codebox}


\newpage


\subsection*{Solution: Discriminant}
\begin{codebox}[exo5-1.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    double a, b, c;
    double discriminant;
    
    printf("Please enter parameter a: ");
    scanf("%lf", &a);
    printf("Please enter parameter b: ");
    scanf("%lf", &b);
    printf("Please enter parameter c: ");
    scanf("%lf", &c);
    
    discriminant = b * b - 4 * a * c;
    
    if      (discriminant < 0) {printf("no solution\n");}
    else if (discriminant < 0) {printf("one solution\n");}
    else                       {printf("two solutions\n");}
}
\end{minted}
\end{codebox}


\subsection*{Solution: Biggest Number}
A version with nested \texttt{if}s:
\begin{codebox}[exo5-2a.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    double a, b, c;
    
    printf("Please enter a first value: ");
    scanf("%lf", &a);
    printf("Please enter a second value: ");
    scanf("%lf", &b);
    printf("Please enter a third value: ");
    scanf("%lf", &c);
    
    if (a > b) {
        if (a > c) {
            printf("The biggest value is %lf\n", a);
        } else {
            printf("The biggest value is %lf\n", c);
        }
    } else {
        if (b > c) {
            printf("The biggest value is %lf\n", b);
        } else {
            printf("The biggest value is %lf\n", c);
        }
    }
}
\end{minted}
\end{codebox}

And one with an auxilliary variable:
\begin{codebox}[exo5-2b.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    double a, b, c;
    double maximum;
    
    printf("Please enter a first value: ");
    scanf("%lf", &a);
    printf("Please enter a second value: ");
    scanf("%lf", &b);
    printf("Please enter a third value: ");
    scanf("%lf", &c);
    
    if (a > b) {
        maximum = a;
    } else {
        maximum = b;
    }
    
    if (maximum < c) {
        maximum = c;
    }
    
    printf("The biggest value is %lf\n", maximum);
}
\end{minted}
\end{codebox}


\subsection*{Solution: Logical vs. Bitwise Operator}
For the bitwise operator \texttt{\&}:\\
\texttt{5 == 101$_2$} and \texttt{2 == 010$_2$}. Since the bits in the same position are never both set, the result is zero or \emph{false}.

For the logical operator \texttt{\&\&}:\\
Both, \texttt{5} and \texttt{2} are nonzero and therefore count as \emph{true}. \emph{true and true} yields \emph{true}.


\subsection*{Solution: Equivalence}
\begin{itemize}
\item \texttt{x > 0} and \texttt{!(x < 0)} are \emph{NOT equivalent}.\\
	Since \texttt{x} can be \emph{equal to zero}, the negated equivalent would be \texttt{!(x <= 0)}.

\item \texttt{!!x} and \texttt{x != 0} are \emph{EQUIVALENT}.\\
	Note that the expression \texttt{!!x} is a \emph{double} negation. In the chapter we encountered the fact that \texttt{!x} is equivalent to \texttt{x == 0}.
	The negation of this is the claimed equivalence.

\item \texttt{x || !x} and \texttt{1} are \emph{EQUIVALENT}.\\
	Boolean logic is a \emph{binary logic}, \ie there are only \emph{true} and \emph{false}. Than means that either \texttt{x} or \texttt{!x} have to be true.
	The logical \emph{or} of two boolean values of which at least one is guaranteed to be \emph{true} will also be \emph{true}, which is represented by the value \texttt{1}.
	
\item \texttt{!(x || y)} and \texttt{(!x) \&\& (!y)} are \emph{EQUIVALENT}.\\
	This is known as \emph{De Morgan's law} and can be proven with a \emph{truth table}:\\
	{
		\newcolumntype{N}{>{\ttfamily\centering\arraybackslash} p{.05\linewidth}}
		\newcolumntype{W}{>{\ttfamily\centering\arraybackslash} p{.15\linewidth}}
		\rowcolors{1}{white}{tabhighlight}
		\begin{tabularx}
			{.51\linewidth}
			{NN|WW}
			x & y &  !(x || y) & (!x) \&\& (!y) \tabcrlf
			
			T & T &          F & F \\
			T & F &          F & F \\
			F & T &          F & F \\
			F & F &          T & T \\
			
		\end{tabularx}
	}
	
	The two right hand side columns of this table agree, so the two expressions are equivalent.
	
	Note that De Morgan's law also states that \texttt{!(x \&\& y)} and \texttt{!x || !y} are equivalent (see next bullet point)
	
\item \texttt{!(x \&\& y)} and \texttt{!x \&\& !y} are \emph{NOT equivalent}.\\
	Again, we can regard the following truth table, which for completeness also contains the corrected form:\\
	{
		\newcolumntype{N}{>{\ttfamily\centering\arraybackslash} p{.05\linewidth}}
		\newcolumntype{W}{>{\ttfamily\centering\arraybackslash} p{.15\linewidth}}
		\rowcolors{1}{white}{tabhighlight}
		\begin{tabularx}
			{.69\linewidth}
			{NN|WW|W}
			x & y &  !(x \&\& y) & (!x) \&\& (!y) & (!x) || (!y) \tabcrlf
			
			T & T &            F & F              & F \\
			T & F &            T & F              & T \\
			F & T &            T & F              & T \\
			F & F &            T & T              & T \\
			
		\end{tabularx}
	}

	The third and fourth column do not agree which shows that the expressions are not equivalent.

\item \texttt{x || (y \&\& z)} and \texttt{(x || y) \&\& (x || z)} are \emph{EQUIVALENT}.\\
	This is the \emph{or} form of the \emph{boolean distributive law}. Again, it can be shown with a truth table:\\
	{
		\newcolumntype{N}{>{\ttfamily\centering\arraybackslash} p{.05\linewidth}}
		\newcolumntype{W}{>{\ttfamily\centering\arraybackslash} p{.25\linewidth}}
		\rowcolors{1}{white}{tabhighlight}
		\begin{tabularx}
			{.79\linewidth}
			{NNN|WW}
			x & y & z & x || (y \&\& z) & (x || y) \&\& (x || z) \tabcrlf
			
			T & T & T &               T & T \\
			T & T & F &               T & T \\
			T & F & T &               T & T \\
			T & F & F &               T & T \\
			F & T & T &               T & T \\
			F & T & F &               F & F \\
			F & F & T &               F & F \\
			F & F & F &               F & F \\
			
		\end{tabularx}
	}
	
	There is also an \emph{and} form of the \emph{boolean distributive law}, which states that\\
	\texttt{x \&\& (y || z)} and \texttt{(x \&\& y) || (x \&\& z)} are equivalent.
	
\end{itemize}


\subsection*{Solution: Non-Equivalent \inC{switch}/\inC{if} constructs}
The second code will output \texttt{other}. 

In the \inC{switch} example, the expression \texttt{++var} is evaluated only once. The value of \texttt{var} is set to \inC{1}, which is also the result of the expression. Consequently, we jump into the branch \inC{case 1} and output \texttt{one} as expected.

In the \inC{if} example, on the other hand, each \inC{if} statement newly evaluates the expression \texttt{++var}. Thus, \texttt{var} is updated before every comparison. Since none of the constants match the current value of \texttt{var}, we arrive in the \inC{else} clause.

This task aimed at showing you why it is a bad idea to put expressions with side effects into \inC{if} or \inC{switch} statements. Even if the result of a statement with side effects must be at the core of a condition, it is better to store this result in an auxiliary variable. If you preface the \inC{if} or \inC{switch} statements with the line \inC{int aux = ++var;} and make \texttt{aux} the subject of the comparisons (\inC{if (aux == 0) ...}, you will find both versions of the code to yield the same result.


\subsection*{Solution: Refactory}
\begin{codebox}[exo5-6.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    int var = /* some value */;

    if ((var % 2) && (var >= 5) && (var <= 10)) {
        printf("%d is odd and between 5 and 10.\n", var);
    }
}
\end{minted}
\end{codebox}

\begin{codebox}[exo5-6-bonus.c]
\begin{minted}[linenos]{c}
#include <stdio.h>

int main () {
    int var = /* some value */;

    if (var % 10 == 1) {
        printf("The last digit of %d is 1.\n", var);
    }
}
\end{minted}
\end{codebox}